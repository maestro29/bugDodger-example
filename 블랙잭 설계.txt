
=============================
오후 4:37 2023-06-15
================================
updateUI는 각각의 버튼을 누를 때 마다 발생하므로,

stay가 아닌

hit, double, split 버튼을 누를 때 마다 발생한다.
그렇단 얘기는 그럴 때 마다 determineWinner를 한다는 소리고,

그렇다면, 이미 승패가 결정난 핸드의 경우에도 다시한번 determineWinner를 탈 수가 있단 소리.
어떻게 할까?

roundComplete가 한번 true로 되어서, determineWinner를 탄 경우,
roundComplete를 다시 false로 변경해야 하나?

문제 없을까?

승패가 결정난 경우, 모든 버튼이 비활성화 될 테니, 버튼을 다시 누를 일은 없다고 보장한다면
문제는 없을 것 같다..


stay를 누르면, 아직 끝나지 않은 모든 판에 대해서 딜러턴을 진행시키고
승패결정을 해야한다.
그럼 결국 두 가지가 필요하다.
 1) 액션이 끝났는지
 2) 정산을 했는지

determineWinner는 액션이 끝났고, 정산을 하지 않은 핸드에 대해서만
진행해야 한다.

잠깐, 플레이어 버스트는 무조건 배팅액 잃는 것이 맞다.
하지만 플레이어 블랙잭은 초구 블랙잭이 아닌 이상,  (스플릿 블랙잭)
블랙잭 표시만 띄우고, 정산은 딜러카드를 다 깐 후에 하여야 한다.
(만약 딜러의 공개카드가 블랙잭 가능성이 없다면 바로 정산 가능)

딜 - 블랙잭 가능
힛 - 버스트 가능
더블 - 버스트 가능
스플릿 - 블랙잭 가능
스테이


버튼 켜고 끄는 거 다시 생각해보자.



==============================================
오전 10:44 2023-06-14
==============================================
설계를 다시 해보자.
 - player-panel
   - player-hand (card-container)
   - player-hand-text (합계 표시)
   - button 5종



class PlayerPanel
생성자
 - 폼 요소 생성
    - dealButton
    - hitButton
    - doubleButton
    - splitButton
    - stayButton
 - 버튼 이벤트 생성 및 연결

변수
 - 핸드(카드) hand[]
 - 딜러 핸드와의 승패 결정이 났는지 여부 roundComplete
 - 더블버튼 비활성화 여부 disableDouble

메서드
 - show
 - hide
 - determineWinner
 - 


updateUI는 전역함수로 가야겠다.
현실세계에서 딜러는 무조건 카드를 하나씩만 줄 수 있으니,
그걸 고려해서 한 번 만 호출하도록 싱크를 맞추자.
대신, 가장 최근에 추가된 핸드부터 드로우를 하자.
그래야만 기존 카드들은 그대로 남아 있으면서 새로운 카드만 
추가되는 듯한 효과를 준다.





============================================
   스플릿 구현
============================================

playerHand[] 는 배열로 만들어야 겠다. (따라서 2차원 배열)


게임 시작 시 디폴트로 
 - drawPlayerTable(1)


만약 스플릿을 누르면,
 - drawPlayerTable(2)
  -> 핸드 
  -> 핸드 그리기
  -> 핸드 합계 텍스트 표시
  -> 5종 버튼 이벤트 생성 및 연결 (두 번째 이상의 핸드의 딜버튼은 항상 비할성화)
       (or 딜 빼던지,)


플레이어의 모든 핸드의 모든 동작이 끝나면, 딜버튼 활성화.

승패 계산. 딜러 vs  플레이어의 모든 핸드

딜버튼을 누르면 첫 핸드를 제외한 나머지 핸드는 삭제.